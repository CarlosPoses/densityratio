---
title: "Introduction"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(densityratio)
```

# Introduction

The goal of the `densityratio` package is to provide an accessible, complete and easy way to perform density ratio estimation. It includes functionality to estimate density ratios using different methods, summarize and examine the results - including visualization features.

In this vignette, we guide through a full user case: how to estimate density ratios, how to examine and visualize the results, and a use case of density ratios in practice for covariate shift adaptation.

# Data

Throughout the vignette, we illustrate the functionality using the 'kids' dataset. The dataset comes from Gelman et al. (2023), and it can be downloaded [here](https://github.com/avehtari/ROS-Examples/tree/master/KidIQ/data). The dataset has five variables: 

- kid_score: the score of each kid in a test
- mom_hs: whether the mother has a high school degree (1) or not (0)
- mom_iq: the IQ of the mother
- mom_work: mother did not work in first three years of child’s life (1), worked in second or third year (2), worked part-time first year (3), worked full-time in first year (4).
- mom_age: the age of the mother in years

To showcase how density ratio estimation works, we split the data into a numerator and denominator samples, in two ways. First, we take random samples of the data, so that the numerator and denominator samples have the same distribution. 

```{r}
data <- readRDS("kids.rds") 
set.seed(444)
# Numerator and denominator have equal distributions
index <- sample(1:nrow(data), size = nrow(data) * 0.5)
eq_numerator <- data[index,, drop = FALSE]
eq_denominator <- data[-index,, drop = FALSE]
```

Second, we take a sample of the data, but we make the probabilities of being assigned to the numerator or denominator sample unequal: they directly depending on the IQ of the mother. We could imagine this split as two samples of students that come from different schools, where moms with higher IQ tend to send children to one of the schools. 


```{r}
library(dplyr)
# Numerator and denominator have different distributions
set.seed(444)
prob <- data |> 
  mutate(z = -38 + 0.4*mom_iq,
         prob = 1/(1 + exp(-z))) 
index <- sample(1:nrow(data), size = nrow(data) * 0.5, prob = prob$prob)
dif_numerator <- data[index,, drop = FALSE]
dif_denominator <- data[-index,, drop = FALSE]
```


# Density ratio estimation

A density ratio is simply a ratio of the density of two samples:
$$r(x) = \frac{p_\text{nu}(x)}{p_{\text{de}}(x)},$$ 

The package provides functionality to estimate a density ratio using different methods, most notably without directly estimating the numerator and denominator densities separately. The key idea is that differences between data distributions can be captured in their density ratio, which is estimated
over the entire multivariate space of the data. Subsequently, the density ratio values can be examined or summarized in different ways. Density ratio estimation serves many purposes, for example, prediction, outlier detection, change-point detection in time-series, importance weighting
under domain adaptation (i.e., sample selection bias) and evaluation of synthetic data utility. 


The package includes different methods for density ratio estimation. Each of these methods has its own function, but all the functions work similarly. The user provides two datasets (numerator and denominator), and the function returns a `densityratio` object, which can be used and examined.

For instance, we can use the function `ulsif()`, which accounts for 'unconstrained least-squares importance fitting'. The function is called as follows:

```{r}
densratio_diff <- ulsif(dif_numerator, dif_denominator)
densratio_eq <- ulsif(eq_numerator, eq_denominator)
```
There is extra control of the details of each method by fine-tuning the function arguments. To check them, simply tipe `?ulsif`. If no extra parameters are provided, the function uses default values. When possible, optimal parameters are determined through cross-validation. Different methods are available for the resulting object.

```{r}
summary(densratio_diff, test = TRUE)
summary(densratio_eq,test = TRUE)
```
The summary method displays information regarding estimation (e.g., optimal sigma and lambda), the Pearson divergence (a measure of discrepancy between densities), and the test results. The rest results are interpreted as follows ...ADD.

Other density ratio estimation methods are available, concretely: Kullback-Leibler importance estimation procedure (`kliep()`), ratio of estimated densities (`naive()`), ratio of estimated densities after dimension reduction (`naivesubspace()`), least-squares heterodistributional subspace search (`lhss()`), and 'spectral estimation?` (`spectral()`).

There is also a `print` method, and a `predict` method. The predict method can be used to predict density ratios for new data, or to get the density ratio predictions for the observed data.

```{r}
# predict(densratio, data = numerator)
print(densratio_diff)
```


# Visualization methods

The package includes different visualization methods to examine the density ratio results. The plots are built with `ggplot2`, and thus return a customizable `ggplot2` object. 

The default `plot` method results in a histogram of the log of the density ratio values. The `plot()` method takes different arguments, so you can plot the density ratio for only some samples, using the original (and not log transformed) scale, etc. You can check them with `?plot.ulsif`.

The default function is meant to given an overview of the similarity of the samples. For equal samples, the density ratio should be 1, and thus its log should be zero. Therefore, we expect the distribution to be centered around zero, and with no major differences of the distribution between numerator and denominator samples. 

```{r}
plot(densratio_eq)
```


In cases where the numerator and denominator samples have different densities, the density ratio values will be different from 1. We expect to see differences in the distributions between the numerator and denominator samples. For instance, we see here how most numerator samples have values larger than 0 (i.e., their density ratio is higher than 1), and most denominator samples have values lower than 0 (i.e., their density ratio is lower than 1). Notice the change of the scale of x-axis between the next and previous plots.
´
```{r}
plot(densratio_diff)
```
There are two other visualization functions, `plot_univariate()` and `plot_bivariate()`. The `plot_univariate()` function plots the value of the density ratio for each variable separately, against the density ratio, and see if there are any patterns. For instance, we can plot the density ratio against the values of "mom_iq". 

```{r}
plot_univariate(densratio_diff, vars = "mom_iq")
```

There is a very clear pattern with: in general, lower values of mom_iq correspond to lower density ratios, and they tend to correspond to denominator smaples. Higher values of mom IQ tend to display higher density ratios, and they correspond to the numerator sample. This is exactly what we expected, because we created data where pertaning to the numerator or denominator sample depending on the mom's IQ.

We can also plot the same plot for all variables at once, allowing us to see that some (milder) relationships are present with respect to the kid's score, whether mom's have a high_school diploma. This is also not surprising, because this variables are correlated with mom's IQ. Sometimes, the points in the scatter plot overlap, so that the differences between numerator and denominator samples are not obvious. We can change that with the 'sample.facet' argument.

```{r}
plot_univariate(densratio_diff, grid = TRUE, sample.facet = TRUE)
```

Plotting only some variables, or displaying each individual plot in a list, is also possible.


On the other hand, the `plot_bivariate()` function plots the value of the density ratio for pairs of variables. We need to select which variables we want to plot, and the function will plot a scatterplot of both variables, for each combination of variables, and color the points according to the density ratio values.

```{r}
plot_bivariate(densratio_diff, vars = c("kid_score", "mom_iq", "mom_hs", "mom_age"), grid = FALSE)
?plot_bivariate
str(data)
```
The bivariate plot gives a nice overview of how the densityratio varies on multivariate space. For instance, it is clear that lower values of body mass index are associated with lower density ratios (i.e., this values are more likely to appear in the denominator data). There is also an interesting relationship between bill depth and the densityratio. For low values of bill depth, the log of the densityratio is 1, meaning these observations are more likely to come from the numerator data. The relatioship changes depending ont he values of the other variables, etc.


# User case: covariate shift adaptation

```{r}
library(randomForest)
library(gbm)

train <- dif_denominator
test <- dif_numerator
weights<-predict(densratio_diff, newdata = train)

# Do same as randomforest, but for logistic model
lm_train <- lm(formula = mom_iq ~ . ,
    data = train)

# Compute RMSE in test data
sum((predict(lm_train, test) - test$mom_iq)^2/nrow(test))

lm_train_reweighted <- glm(formula = mom_iq ~ . ,
    data = train, 
    weights = weights)

sum((predict(lm_train_reweighted, test) - test$mom_iq)^2/nrow(test))
```


```{r}
randomforest <- randomForest(mom_iq ~ . , train)
randomforest_reweighted <- randomForest(mom_iq ~ . , train, weights = weights)
sum((predict(randomforest, test) - test$mom_iq)^2/nrow(test))
sum((predict(randomforest_reweighted, test) - test$mom_iq)^2/nrow(test))

```



lm, randomForest, gbm
